# -*- coding: utf-8 -*-
"""Modulo para la graficación de vectores.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Icwf-1baCl2S4iqdV3jvOdqKVcpz-wPV

<p><img alt="logo.fua" height="100px" src="https://www.uamerica.edu.co/wp-content/images/escudo.png" align="left" hspace="10px" vspace="0px"></p>

<p><img alt="logo.fua" height="26px" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-nd.svg" align="right" hspace="0px" vspace="11px"></p>


# <center> <font size="6"> &nbsp;  &nbsp; &nbsp;  &nbsp; &nbsp;  &nbsp; &nbsp;  &nbsp; &nbsp;  &nbsp;**ÁLGEBRA LINEAL CON PYTHON &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     &nbsp; &nbsp;  &nbsp; MÓDULO PARA LA GRAFICACIÓN DE VECTORES** &nbsp;  &nbsp; &nbsp;  &nbsp; &nbsp;  &nbsp; &nbsp;  &nbsp; <center> &nbsp; &nbsp; &nbsp; &nbsp;*Jhonny Osorio Gallego* &nbsp; &nbsp; &nbsp;<p></font>

El siguiente módulo esta diseñado haciendo uso de la librería **NumPy** y **Plotly**, pretende servir de apoyo para la representación gráfica de vectores en el plano y el espacio, como estratégia para la enseñanza de los concéptos vectoriales.

## **FUNCIÓN PARA GENERAR COLORES RGB ALEATORIAMENTE**
"""

import random 
def randomRgbaColor(): 
   r = random.randrange(0, 255) 
   g = random.randrange(0, 255)  
   b =random.randrange(0, 255)
   return "rgb"+ "(" + str(r) + "," + str(g) + ","+ str(b) + ")"

"""## **DEFINICIÓN UNA FUNCIÓN PARA GRAFICAR MULTIPLES VECTORES FIJOS EN EL PLANO**

La función tiene como sintaxis **plotvectorsf2D** permite graficar multiples vectores en el plano cartesiano, acepta vectores definidos en la librería SymPy.
"""

import plotly.graph_objects as go
import numpy as np
from sympy import Matrix


def plotvectorsf2D(*args):

    '''Función elaborada con el módulo Plotly y NumPy  para representar multiples vectores fijos en el plano'''
    
    fig = go.Figure()
    x = [0]
    y = [0]
    L = []

    for V in args:
        
        if type(V) == list:
            color = randomRgbaColor()
            x.append(V[0])
            y.append(V[1])
            #fig.add_trace(go.Scatter(x=[V[0]],y=[V[1]],mode='markers',marker=dict(color= color,size=7),showlegend=True,name="vector "+ str(args.index(V)+1)))
            fig.add_trace(go.Scatter(x=[0,V[0]], y=[0,V[1]],mode='lines',marker=dict(color= color,size=8),showlegend=True,name="vector "+ str(args.index(V)+1)))
            fig.add_annotation(
            x=V[0],  # Coordenada en x cabeza
            y=V[1],  # Coordenada en y cabeza
            ax=0.0,  # Coordenada en x de la cola
            ay=0.0,  # Coordenada en x de la cola
            xref='x',
            yref='y',
            axref='x',
            ayref='y',
            showarrow=True,
            arrowhead=2,
            arrowsize=1.5,
            arrowwidth=2.3,
            arrowcolor = color)
        
        else:

            color = randomRgbaColor()
            a = np.array(V).astype(np.float64).tolist()[0][0]
            b = np.array(V).astype(np.float64).tolist()[1][0]
            x.append(a)
            y.append(b)
            #fig.add_trace(go.Scatter(x=[V[0]],y=[V[1]],mode='markers',marker=dict(color= color,size=7),showlegend=True,name="vector "+ str(args.index(V)+1)))
            fig.add_trace(go.Scatter(x=[0,a], y=[0,b],mode='lines',marker=dict(color= color,size=8),showlegend=True,name="vector "+ str(args.index(V)+1)))
            fig.add_annotation(
            x=a,  # Coordenada en x cabeza
            y=b,  # Coordenada en y cabeza
            ax=0.0,  # Coordenada en x de la cola
            ay=0.0,  # Coordenada en x de la cola
            xref='x',
            yref='y',
            axref='x',
            ayref='y',
            showarrow=True,
            arrowhead=2,
            arrowsize=1.5,
            arrowwidth=2.3,
            arrowcolor = color)

    fig.add_trace(go.Scatter(x=[0],y=[0],mode='markers',marker=dict(color="#2a3f5f",size=9),showlegend=True,opacity=1,name="origen"))

    fig.add_annotation(ax = min(x)-0.54, axref = 'x', ay = 0, ayref = 'y',x = max(x)+0.5, xref = 'x', y = 0, yref = 'y',arrowwidth = 1.5, arrowhead = 2,arrowcolor = "#2a3f5f")
    fig.add_annotation(ax = 0, axref = 'x', ay = min(y)-0.54, ayref = 'y',x = 0, xref = 'x', y = max(y)+0.5, yref = 'y',arrowwidth = 1.5, arrowhead = 2,arrowcolor = "#2a3f5f")
    fig.add_annotation(text="$x$", x=max(x)+0.5, y=-0.2, arrowhead=1, showarrow=False)
    fig.add_annotation(text="$y$", x=-0.2, y=max(y)+0.5, arrowhead=1, showarrow=False)

    fig.update_xaxes(title = "$\large{x}$", title_font=dict(size=30, family='latex', color='rgb(1,21,51)'),range = [min(x)-0.5, max(x)+0.5],showgrid = True) #,zerolinecolor="black" ,autorange = True
    fig.update_yaxes(title = "$\large{y}$", title_font=dict(size=30, family='latex', color='rgb(1,21,51)'),range = [min(y)-0.5, max(y)+0.5],showgrid = True) #, zerolinecolor= "black" ,autorange = True
    fig.update_layout(font=dict(family="latex",size=20,color="black")) #y=1.2,x=0.03
    #fig.update_layout(title= "",title_font=dict(size=5, family='latex', color='rgb(1,21,51)'),title_x=0.5)
    fig.update_layout(legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, itemdoubleclick ="toggle"),title_font=dict(size=30, color='rgb(1,21,51)'),showlegend=True,width=500, height=480)
    fig.show()

plotvectorsf2D([3,20],[-10,20],[50,30],[-10,-40],[20,-40])

from sympy import Matrix
A = Matrix([1,2])
plotvectorsf2D(A)

"""## **DEFINICIÓN DE UNA FUNCIÓN PARA GRAFICAR MULTIPLES VECTORES FIJOS EN EL ESPACIO**
La función tiene como sintaxis **plotvectorsf3D** permite graficar multiples vectores en el plano cartesiano.
"""

import plotly.graph_objs as go
from plotly.offline import plot
import numpy as np


def plotvectorsf3D(*args):

    ''''Función elaborada con el módulo Plotly y NumPy para representar gráficamente multiples vectores fijos en el espacio'''
    data = []
    x = [0]
    y = [0]
    z = [0.3,-0.3]
    
    for V in args:
        x.append(V[0])
        y.append(V[1])
        z.append(V[2])
    
    escala =(max(x)+max(y)+max(z))/15
    
    
    
    for V in args:
        x.append(V[0])
        y.append(V[1])
        z.append(V[2])
        color = randomRgbaColor()
        vector = go.Scatter3d( 
        x = [0,V[0]],
        y = [0,V[1]],
        z = [0,V[2]],
        marker = dict( size = 1,color= color),
        line = dict( color= color, width = 7),name="vector "+ str(args.index(V)+1))
        
        paleta = [[0, color],[1, color]]

        cono = go.Cone(x=[V[0]], y=[V[1]], z=[V[2]], u=[V[0]], v=[V[1]], w=[V[2]],sizemode="absolute",sizeref= escala,anchor="cm",
               showscale=False,
               colorscale=paleta,
               colorbar=dict(thickness=20, ticklen=4),
               name="vector "+ str(args.index(V)+1))
        
        data += [vector,cono]
        layout = go.Layout(margin = dict( l = 0,r = 0,b = 0,t = 0))

    paleta2 = [[0, "#2a3f5f"],[1, "#2a3f5f"]]
    point = go.Scatter3d( x = [0],y = [0],z = [0], mode='markers',marker=dict(color= "#2a3f5f",size=5),showlegend=True,name="origen")
    
    axex = go.Scatter3d( 
        x = [min(x)-escala, max(x)+escala],
        y = [0,0],
        z = [0,0],
        hoverinfo = "skip",
        marker = dict( size = 1,color= "#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="")
    
    
    conox = go.Cone(x=[max(x)+ escala], y=[0], z=[0], u=[max(x)+escala], v=[0], w=[0],sizemode="absolute",sizeref=escala*0.6,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo = "name",
               colorbar=dict(thickness=20, ticklen=4),name="Eje x-positivo")
    
    axey = go.Scatter3d( 
        x = [0,0],
        y = [min(y)-escala,max(y)+escala],
        z = [0,0],
        hoverinfo = "skip",
        marker = dict( size = 1,color="#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="")
    
    conoy = go.Cone(x=[0], y=[max(y)+escala], z=[0], u=[0], v=[max(y)+escala], w=[0],sizemode="absolute",sizeref=escala*0.6,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo = "name",
               colorbar=dict(thickness=20, ticklen=4),
               name="Eje y-positivo ")
    
    axez = go.Scatter3d( 
        x = [0,0],
        y = [0,0],
        z = [min(z)-escala,max(z)+escala],
        hoverinfo = "skip",
        marker = dict( size = 1,color= "#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="eje z-positivo")
    
    conoz = go.Cone(x=[0], y=[0], z=[max(z)+escala], u=[0], v=[0], w=[max(z)+escala],sizemode="absolute",sizeref=escala*0.6,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo= "name",
               colorbar=dict(thickness=20, ticklen=4),
               name="Eje z-positivo")
    
    
    #plano = go.Surface(x = np.linspace(min(x),max(x),500), y = np.linspace(min(y),max(y),500) ,z = np.zeros(500),showscale=False)

    fig = go.Figure(data= data + [point, axex, conox, axey, conoy, axez, conoz] ,layout=layout)


    fig.update_layout(legend=dict(orientation="h",y=1.3,x=0.03),title_font=dict(size=50, color='rgb(1,21,51)'),showlegend=True,width=480, height=480)


    plot(fig,image_height=800,image_width=800)
    fig.show()

plotvectorsf3D([1,2,-3],[2,-3,1],[-2,-4,5])

"""## **DEFINICIÓN DE UNA FUNCIÓN PARA GRAFICAR MULTIPLES VECTORES LIBRES EN EL PLANO**
La función tiene como sintaxis **plotvectorsl2D** permite graficar multiples vectores libres en el plano cartesiano.
"""

import plotly.graph_objects as go
import numpy as np


def plotvectorsl2D(*args):
    '''Función elaborada en el módulo Plotly y NumPy para reprsentar graficamente multiples vectores libres en el plano'''
    
    fig = go.Figure()
    x = [0] 
    y = [0]
    for V in args:
        color = randomRgbaColor()
        x.append(V[0][0])
        x.append(V[1][0])
        y.append(V[0][1])
        y.append(V[1][1])
        #fig.add_trace(go.Scatter(x=[V[0]],y=[V[1]],mode='markers',marker=dict(color= color,size=7),showlegend=True,name="vector "+ str(args.index(V)+1)))
        fig.add_trace(go.Scatter(x=[V[0][0],V[1][0]], y=[V[0][1],V[1][1]],mode='lines',marker=dict(color= color,size=8),showlegend=True,name="vector "+ str(args.index(V)+1)))
        fig.add_annotation(
        x=V[1][0],  # Coordenada en x cabeza
        y=V[1][1],  # Coordenada en y cabeza
        ax=V[0][0],  # Coordenada en x de la cola
        ay=V[0][1],  # Coordenada en y de la cola
        xref='x',
        yref='y',
        axref='x',
        ayref='y',
        showarrow=True,
        arrowhead=2,
        arrowsize=1.5,
        arrowwidth=2.3,
        arrowcolor = color)
        
    fig.add_trace(go.Scatter(x=[0],y=[0],mode='markers',marker=dict(color="#2a3f5f",size=9),showlegend=True,opacity=1,name="origen"))

    fig.add_annotation(ax = min(x)-0.54, axref = 'x', ay = 0, ayref = 'y',x = max(x)+0.5, xref = 'x', y = 0, yref = 'y',arrowwidth = 1.5, arrowhead = 2,arrowcolor = "#2a3f5f")
    fig.add_annotation(ax = 0, axref = 'x', ay = min(y)-0.54, ayref = 'y',x = 0, xref = 'x', y = max(y)+0.5, yref = 'y',arrowwidth = 1.5, arrowhead = 2,arrowcolor = "#2a3f5f")
    fig.add_annotation(text="$x$", x=max(x)+0.5, y=-0.2, arrowhead=1, showarrow=False)
    fig.add_annotation(text="$y$", x=-0.2, y=max(y)+0.5, arrowhead=1, showarrow=False)

    fig.update_xaxes(title = "$\large{x}$", title_font=dict(size=30, family='latex', color='rgb(1,21,51)'),range = [min(x)-0.5, max(x)+0.5],showgrid = True) #,zerolinecolor="black" ,autorange = True
    fig.update_yaxes(title = "$\large{y}$", title_font=dict(size=30, family='latex', color='rgb(1,21,51)'),range = [min(y)-0.5, max(y)+0.5],showgrid = True) #, zerolinecolor= "black" ,autorange = True
    fig.update_layout(font=dict(family="latex",size=20,color="black")) #y=1.2,x=0.03
    #fig.update_layout(title= "",title_font=dict(size=5, family='latex', color='rgb(1,21,51)'),title_x=0.5)
    fig.update_layout(legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, itemdoubleclick ="toggle"),title_font=dict(size=30, color='rgb(1,21,51)'),showlegend=True,width=500, height=480)
    fig.show()

plotvectorsl2D([(1,2),(3,4)],[(3,4),(2,2)],[(2,2),(0,0)],[(0,0),(1,2)])

"""## **DEFINICIÓN DE UNA FUNCIÓN PARA GRAFICAR EN EL PLANO MULTIPLES VECTORES LIBRES O FIJOS Y EQUIPOLENTES CON INICIO EN UN PUNTO DADO**
La función tiene como sintaxis **plotvectors2d** permite graficar multiples vectores libres y fijos en el plano cartesiano, ademas de vectores equipolentes que inicien en un punto dado, acepta como argumento vectores de la librería SymPy.
"""

import plotly.graph_objects as go
import numpy as np


def plotvectors2D(*args):
    '''Función elaborada con el módulo Plotly y Numpy para representar multiples vectores fijos y libres en el plano  
    ademas de vectores equipolentes que inicien en un punto dado, acepta como argumento vectores de la librería SymPy.'''
    fig = go.Figure()
    x = [0]
    y = [0]
    for V in args:

        nombre = "vector "+ str(args.index(V)+1)

        if type(V)== list and len(V) == 1:

            color = randomRgbaColor()
            x.append(V[0])
            y.append(0)
            #fig.add_trace(go.Scatter(x=[V[0]],y=[V[1]],mode='markers',marker=dict(color= color,size=3),showlegend=True,name=nombre))
            fig.add_trace(go.Scatter(x=[0,V[0]], y=[0,0],mode='lines',marker=dict(color= color,size=8),showlegend=True,name= nombre))
            fig.add_annotation(
            x=V[0],  # Coordenada en x cabeza
            y=0,  # Coordenada en y cabeza
            ax=0.0,  # Coordenada en x de la cola
            ay=0.0,  # Coordenada en x de la cola
            xref='x',
            yref='y',
            axref='x',
            ayref='y',
            showarrow=True,
            arrowhead=2,
            arrowsize=1.5,
            arrowwidth=2.3,
            arrowcolor = color)
        
        else:
            
            if type(V[0]) == int or type(V[0]) == float :
            
                color = randomRgbaColor()
                x.append(V[0])
                y.append(V[1])
                #fig.add_trace(go.Scatter(x=[V[0]],y=[V[1]],mode='markers',marker=dict(color= color,size=3),showlegend=True,name=nombre))
                fig.add_trace(go.Scatter(x=[0,V[0]], y=[0,V[1]],mode='lines',marker=dict(color= color,size=8),showlegend=True,name= nombre))
                fig.add_annotation(
                x=V[0],  # Coordenada en x cabeza
                y=V[1],  # Coordenada en y cabeza
                ax=0.0,  # Coordenada en x de la cola
                ay=0.0,  # Coordenada en x de la cola
                xref='x',
                yref='y',
                axref='x',
                ayref='y',
                showarrow=True,
                arrowhead=2,
                arrowsize=1.5,
                arrowwidth=2.3,
                name="Markers and Text",
                arrowcolor = color)
                
            if  type(V[0]) == tuple:
                
                if type(V[1]) == list:

                    if len(V[1])==1:
                        
                        color = randomRgbaColor()
                        x.append(V[0][0])
                        x.append(V[1][0]+V[0][0])
                        y.append(V[1][0])
                        y.append(0+V[0][1])
                        #fig.add_trace(go.Scatter(x=[V[1][0]+V[0][0]],y=[V[1][1]+V[0][1]],mode='markers',marker=dict(color= color,size=3),showlegend=True,name=nombre))
                        fig.add_trace(go.Scatter(x=[V[0][0],V[0][0]+V[1][0]], y=[V[0][1],V[0][1]+0],mode='lines',marker=dict(color= color,size=8),showlegend=True,name= nombre))
                        fig.add_annotation(
                        x=V[0][0]+V[1][0],  # Coordenada en x cabeza 
                        y=V[0][1]+0,  # Coordenada en y cabeza
                        ax=V[0][0],  # Coordenada en x de la cola
                        ay=V[0][1],  # Coordenada en y de la cola
                        xref='x',
                        yref='y',
                        axref='x',
                        ayref='y',
                        showarrow=True,
                        arrowhead=2,
                        arrowsize=1.5,
                        arrowwidth=2.3,
                        arrowcolor = color)
                    
                    else:

                        color = randomRgbaColor()
                        x.append(V[0][0])
                        x.append(V[1][0]+V[0][0])
                        y.append(V[1][0])
                        y.append(V[1][1]+V[0][1])
                        #fig.add_trace(go.Scatter(x=[V[1][0]+V[0][0]],y=[V[1][1]+V[0][1]],mode='markers',marker=dict(color= color,size=3),showlegend=True,name=nombre))
                        fig.add_trace(go.Scatter(x=[V[0][0],V[0][0]+V[1][0]], y=[V[0][1],V[0][1]+V[1][1]],mode='lines',marker=dict(color= color,size=8),showlegend=True,name= nombre))
                        fig.add_annotation(
                        x=V[0][0]+V[1][0],  # Coordenada en x cabeza 
                        y=V[0][1]+V[1][1],  # Coordenada en y cabeza
                        ax=V[0][0],  # Coordenada en x de la cola
                        ay=V[0][1],  # Coordenada en y de la cola
                        xref='x',
                        yref='y',
                        axref='x',
                        ayref='y',
                        showarrow=True,
                        arrowhead=2,
                        arrowsize=1.5,
                        arrowwidth=2.3,
                        arrowcolor = color)

                    
                if type(V[1]) == tuple:
                    
                    color = randomRgbaColor()
                    x.append(V[0][0])
                    x.append(V[1][0])
                    y.append(V[0][1])
                    y.append(V[1][1])
                    #fig.add_trace(go.Scatter(x=[V[1][0]],y=[V[1][1]],mode='markers',marker=dict(color= color,size=3),showlegend=True,name=nombre))
                    fig.add_trace(go.Scatter(x=[V[0][0],V[1][0]], y=[V[0][1],V[1][1]],mode='lines',marker=dict(color= color,size=8),showlegend=True,name= nombre))
                    fig.add_annotation(
                    x=V[1][0],  # Coordenada en x cabeza
                    y=V[1][1],  # Coordenada en y cabeza
                    ax=V[0][0],  # Coordenada en x de la cola
                    ay=V[0][1],  # Coordenada en y de la cola
                    xref='x',
                    yref='y',
                    axref='x',
                    ayref='y',
                    showarrow=True,
                    arrowhead=2,
                    arrowsize=1.5,
                    arrowwidth=2.3,
                    arrowcolor = color)
                    
                if type(V[1]) != list and type(V[1]) != tuple:

                    if len(V[1])== 1:
                        
                        color = randomRgbaColor()
                        a = np.array(V[1]).astype(np.float64).tolist()[0][0]
                        b = 0
                        x.append(V[0][0])
                        x.append(a+V[0][0])
                        y.append(V[0][1])
                        y.append(b+V[0][1])
                        #fig.add_trace(go.Scatter(x=[V[1][0]+V[0][0]],y=[V[1][1]+V[0][1]],mode='markers',marker=dict(color= color,size=3),showlegend=True,name=nombre))
                        fig.add_trace(go.Scatter(x=[V[0][0],V[0][0]+a], y=[V[0][1],V[0][1]+b],mode='lines',marker=dict(color= color,size=8),showlegend=True,name= nombre))
                        fig.add_annotation(
                        x=V[0][0]+a,  # Coordenada en x cabeza 
                        y=V[0][1]+b,  # Coordenada en y cabeza
                        ax=V[0][0],  # Coordenada en x de la cola
                        ay=V[0][1],  # Coordenada en y de la cola
                        xref='x',
                        yref='y',
                        axref='x',
                        ayref='y',
                        showarrow=True,
                        arrowhead=2,
                        arrowsize=1.5,
                        arrowwidth=2.3,
                        arrowcolor = color)

                    else:
                        
                        color = randomRgbaColor()
                        a = np.array(V[1]).astype(np.float64).tolist()[0][0]
                        b = np.array(V[1]).astype(np.float64).tolist()[1][0]
                        x.append(V[0][0])
                        x.append(a+V[0][0])
                        y.append(V[0][1])
                        y.append(b+V[0][1])
                        #fig.add_trace(go.Scatter(x=[V[1][0]+V[0][0]],y=[V[1][1]+V[0][1]],mode='markers',marker=dict(color= color,size=3),showlegend=True,name=nombre))
                        fig.add_trace(go.Scatter(x=[V[0][0],V[0][0]+a], y=[V[0][1],V[0][1]+b],mode='lines',marker=dict(color= color,size=8),showlegend=True,name= nombre))
                        fig.add_annotation(
                        x=V[0][0]+a,  # Coordenada en x cabeza 
                        y=V[0][1]+b,  # Coordenada en y cabeza
                        ax=V[0][0],  # Coordenada en x de la cola
                        ay=V[0][1],  # Coordenada en y de la cola
                        xref='x',
                        yref='y',
                        axref='x',
                        ayref='y',
                        showarrow=True,
                        arrowhead=2,
                        arrowsize=1.5,
                        arrowwidth=2.3,
                        arrowcolor = color)

        
        if type(V) != list:

            if len(V) == 1:
                color = randomRgbaColor()
                a = np.array(V).astype(np.float64).tolist()[0][0]
                b = 0
                x.append(a)
                y.append(b)
                #fig.add_trace(go.Scatter(x=[a],y=[b],mode='markers',marker=dict(color= color,size=3),showlegend=True,name=nombre))
                fig.add_trace(go.Scatter(x=[0,a], y=[0,b],mode='lines',marker=dict(color= color,size=8),showlegend=True,name= nombre))
                fig.add_annotation(
                x=a,  # Coordenada en x cabeza
                y=b,  # Coordenada en y cabeza
                ax=0.0,  # Coordenada en x de la cola
                ay=0.0,  # Coordenada en x de la cola
                xref='x',
                yref='y',
                axref='x',
                ayref='y',
                showarrow=True,
                arrowhead=2,
                arrowsize=1.5,
                arrowwidth=2.3,
                arrowcolor = color)

            else:

                color = randomRgbaColor()
                a = np.array(V).astype(np.float64).tolist()[0][0]
                b = np.array(V).astype(np.float64).tolist()[1][0]
                x.append(a)
                y.append(b)
                #fig.add_trace(go.Scatter(x=[a],y=[b],mode='markers',marker=dict(color= color,size=3),showlegend=True,name=nombre))
                fig.add_trace(go.Scatter(x=[0,a], y=[0,b],mode='lines',marker=dict(color= color,size=8),showlegend=True,name= nombre))
                fig.add_annotation(
                x=a,  # Coordenada en x cabeza
                y=b,  # Coordenada en y cabeza
                ax=0.0,  # Coordenada en x de la cola
                ay=0.0,  # Coordenada en x de la cola
                xref='x',
                yref='y',
                axref='x',
                ayref='y',
                showarrow=True,
                arrowhead=2,
                arrowsize=1.5,
                arrowwidth=2.3,
                arrowcolor = color)
 

    fig.add_trace(go.Scatter(x=[0],y=[0],mode='markers',marker=dict(color="#2a3f5f",size=9),showlegend=True,opacity=1,name="origen"))

    fig.add_annotation(ax = min(x)-0.54, axref = 'x', ay = 0, ayref = 'y',x = max(x)+0.5, xref = 'x', y = 0, yref = 'y',arrowwidth = 1.5, arrowhead = 2,arrowcolor = "#2a3f5f")
    fig.add_annotation(ax = 0, axref = 'x', ay = min(y)-0.54, ayref = 'y',x = 0, xref = 'x', y = max(y)+0.5, yref = 'y',arrowwidth = 1.5, arrowhead = 2,arrowcolor = "#2a3f5f")
    fig.add_annotation(text="$x$", x=max(x)+0.5, y=-0.2, arrowhead=1, showarrow=False)
    fig.add_annotation(text="$y$", x=-0.2, y=max(y)+0.5, arrowhead=1, showarrow=False)

    fig.update_xaxes(title = "$\large{x}$", title_font=dict(size=30, family='latex', color='rgb(1,21,51)'),range = [min(x)-0.5, max(x)+0.5],showgrid = True) #,zerolinecolor="black" ,autorange = True
    fig.update_yaxes(title = "$\large{y}$", title_font=dict(size=30, family='latex', color='rgb(1,21,51)'),range = [min(y)-0.5, max(y)+0.5],showgrid = True) #, zerolinecolor= "black" ,autorange = True
    fig.update_layout(font=dict(family="latex",size=20,color="black")) #y=1.2,x=0.03
    #fig.update_layout(title= "",title_font=dict(size=5, family='latex', color='rgb(1,21,51)'),title_x=0.5)
    fig.update_layout(legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, itemdoubleclick ="toggle"),title_font=dict(size=30, color='rgb(1,21,51)'),showlegend=True,width=500, height=480)
    fig.show()

from sympy import Matrix

A = Matrix([2,4])

plotvectors2D([(1,2),[5,3]],[2,1], [(7,5),(2,8)],A,[(2,2),A])

A = Matrix([6])
plotvectors2D([(2,4),A])

plotvectors2D([1,2],[(1,2),(4,3)],[4,3],[3,1])

A = Matrix([3])
plotvectors2D(A)

plotvectors2D([2])

plotvectors2D([(1,0),[3]])

"""## **DEFINICIÓN DE UNA FUNCIÓN PARA GRAFICAR MULTIPLES VECTORES LIBRES EN EL ESPACIO**
La función tiene como sintaxis **plotvectorsl3D** permite graficar multiples vectores en el espacio.
"""

import plotly.graph_objs as go
from plotly.offline import plot
import numpy as np


def plotvectorsl3D(*args):
    '''Función elaborada en el módulo Plotly y NumPy para representar graficamente multiples vectores libres en el espacio'''
    data = []
    x = [0]
    y = [0]
    z = [0.3,-0.3]


    for V in args:
        x.append(V[0][0])
        x.append(V[1][0])

        y.append(V[0][1])
        y.append(V[1][1])

        z.append(V[0][2])
        z.append(V[1][2])
    

    escala =(max(x)+max(y)+max(z))/30
    
    
    
    for V in args:
        x.append(V[0][0])
        x.append(V[1][0])

        y.append(V[0][1])
        y.append(V[1][1])

        z.append(V[0][2])
        z.append(V[1][2])

        nombre = "Tail"+ "=" + "(" + str(V[0][0])  + "," + str(V[0][1]) +"," +str(V[0][2]) + ")" + "\n" + "Head"+ "=" + "(" + str(V[1][0])  + "," + str(V[1][1]) +"," +str(V[1][2]) + ")"

        color = randomRgbaColor()
        vector = go.Scatter3d( 
        x = [V[0][0],V[1][0]],
        y = [V[0][1],V[1][1]],
        z = [V[0][2],V[1][2]],
        hoverinfo = "name + text",
        hovertext = nombre,
        marker = dict( size = 1,color= color),
        line = dict( color= color, width = 7),name="vector "+ str(args.index(V)+1))
        
        paleta = [[0, color],[1, color]]

        cono = go.Cone(x=[V[1][0]-0.063*(V[1][0]-V[0][0])], y=[V[1][1]-0.063*(V[1][1]-V[0][1])], z=[V[1][2]-0.063*(V[1][2]-V[0][2])], u=[0.5*(V[1][0]-V[0][0])], v=[0.5*(V[1][1]-V[0][1])], w=[0.5*(V[1][2]-V[0][2])],sizemode="absolute",sizeref=escala,anchor="cm",
               showscale=False,
               colorscale=paleta,
               hoverinfo = "skip",
               colorbar=dict(thickness=20, ticklen=4),
               name="vector "+ str(args.index(V)+1))
        
        data += [vector,cono]
        layout = go.Layout(margin = dict( l = 0,r = 0,b = 0,t = 0))

    paleta2 = [[0, "#2a3f5f"],[1, "#2a3f5f"]]
    point = go.Scatter3d( x = [0],y = [0],z = [0], mode='markers',marker=dict(color= "#2a3f5f",size=5),showlegend=True,name="origen")
    
    axex = go.Scatter3d( 
        x = [min(x)-escala, max(x)+ escala],
        y = [0,0],
        z = [0,0],
        hoverinfo = "skip",
        marker = dict( size = 1,color= "#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="")
    
    
    conox = go.Cone(x=[max(x) + escala], y=[0], z=[0], u=[max(x)+ escala], v=[0], w=[0],sizemode="absolute",sizeref=escala*0.6,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo = "name",
               colorbar=dict(thickness=20, ticklen=4),name="Eje x-positivo")
    
    axey = go.Scatter3d( 
        x = [0,0],
        y = [min(y)-escala,max(y)+escala],
        z = [0,0],
        hoverinfo = "skip",
        marker = dict( size = 1,color="#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="")
    
    conoy = go.Cone(x=[0], y=[max(y)+ escala], z=[0], u=[0], v=[max(y)+escala], w=[0],sizemode="absolute",sizeref=escala*0.6,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo = "name",
               colorbar=dict(thickness=20, ticklen=4),
               name="Eje y-positivo ")
    
    axez = go.Scatter3d( 
        x = [0,0],
        y = [0,0],
        z = [min(z)-escala,max(z)+escala],
        hoverinfo = "skip",
        marker = dict( size = 1,color= "#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="eje z-positivo")
    
    conoz = go.Cone(x=[0], y=[0], z=[max(z)+escala], u=[0], v=[0], w=[max(z)+escala],sizemode="absolute",sizeref=escala*0.6,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo= "name",
               colorbar=dict(thickness=20, ticklen=4),
               name="Eje z-positivo")
    
    
    #plano = go.Surface(x = np.linspace(min(x),max(x),500), y = np.linspace(min(y),max(y),500) ,z = np.zeros(500),showscale=False)

    fig = go.Figure(data= data + [point, axex, conox, axey, conoy, axez, conoz] ,layout=layout)


    fig.update_layout(legend=dict(orientation="h",y=1.3,x=0.03),title_font=dict(size=50, color='rgb(1,21,51)'),showlegend=True,width=480, height=480)


    plot(fig,image_height=800,image_width=800)
    fig.show()

plotvectorsl3D([(1,2,3),(4,5,6)],[(1,2,3),(4,3,6)],[(4,5,6),(4,3,6)])

"""## **DEFINICIÓN DE UNA FUNCIÓN PARA GRAFICAR EN EL ESPACIO MULTIPLES VECTORES LIBRES O FIJOS Y EQUIPOLENTES CON INICIO EN UN PUNTO DADO**
La función tiene como sintaxis **plotvectors3D** permite graficar multiples vectores libres y fijos en el espacio, ademas de vectores equipolentes que inicien en un punto dado, acepta como argumento vectores de la librería SymPy.
"""

import plotly.graph_objs as go
from plotly.offline import plot
import numpy as np


def plotvectors3D(*args):
    '''Función elaborada en el módulo Plotly y NumPy para representar graficamente multiples vectores libres y fijos en el espacio,
    ademas de vectores equipolentes que inicien en un punto dado, acepta como argumento vectores de la librería SymPy'''
    data = []
    x = [0]
    y = [0]
    z = [0.3,-0.3]


    for V in args:

        if type(V[0]) == int or type(V[0]) == float :

            x.append(V[0])
            y.append(V[1])
            z.append(V[2])

        if  type(V[0]) == tuple:

            if  type(V[1]) == tuple:

                x.append(V[0][0])
                x.append(V[1][0])

                y.append(V[0][1])
                y.append(V[1][1])

                z.append(V[0][2])
                z.append(V[1][2])
            
            if  type(V[1]) == list:

                x.append(V[0][0])
                x.append(V[0][0]+V[1][0])

                y.append(V[0][1])
                y.append(V[0][1]+V[1][1])

                z.append(V[0][2])
                z.append(V[0][2]+V[1][2])

            if type(V[1]) != list and type(V[1]) != tuple:

                a = np.array(V[1]).astype(np.float64).tolist()[0][0]
                b = np.array(V[1]).astype(np.float64).tolist()[1][0]
                c = np.array(V[1]).astype(np.float64).tolist()[2][0]

                x.append(V[0][0])
                x.append(V[0][0]+a)

                y.append(V[0][1])
                y.append(V[0][1]+b)

                z.append(V[0][2])
                z.append(V[0][2]+c)


        if type(V) != list:

            a = np.array(V).astype(np.float64).tolist()[0][0]
            b = np.array(V).astype(np.float64).tolist()[1][0]
            c = np.array(V).astype(np.float64).tolist()[2][0]

            x.append(a)
            y.append(b)
            z.append(c)

                    
             
    escala = (max(x)+max(y)+max(z))/30

    
    for V in args:

        if type(V[0]) == int or type(V[0]) == float :
            x.append(V[0])
            y.append(V[1])
            z.append(V[2])
            color = randomRgbaColor()
            vector = go.Scatter3d( 
            x = [0,V[0]],
            y = [0,V[1]],
            z = [0,V[2]],
            marker = dict( size = 1,color= color),
            line = dict( color= color, width = 7),name="vector "+ str(args.index(V)+1))
        
            paleta = [[0, color],[1, color]]

            cono = go.Cone(x=[V[0]], y=[V[1]], z=[V[2]], u=[V[0]], v=[V[1]], w=[V[2]],sizemode="absolute",sizeref=escala,anchor="cm",
               showscale=False,
               colorscale=paleta,
               colorbar=dict(thickness=20, ticklen=4),
               name="vector "+ str(args.index(V)+1))
        
            data += [vector,cono]
            layout = go.Layout(margin = dict( l = 0,r = 0,b = 0,t = 0))

        if  type(V[0]) == tuple:

            if  type(V[1]) == tuple:

                x.append(V[0][0])
                x.append(V[1][0])

                y.append(V[0][1])
                y.append(V[1][1])

                z.append(V[0][2])
                z.append(V[1][2])

                nombre = "Tail"+ "=" + "(" + str(V[0][0])  + "," + str(V[0][1]) +"," +str(V[0][2]) + ")" + "\n" + "Head"+ "=" + "(" + str(V[1][0])  + "," + str(V[1][1]) +"," +str(V[1][2]) + ")"

                color = randomRgbaColor()
                vector = go.Scatter3d( 
                x = [V[0][0],V[1][0]],
                y = [V[0][1],V[1][1]],
                z = [V[0][2],V[1][2]],
                hoverinfo = "name + text",
                hovertext = nombre,
                marker = dict( size = 1,color= color),
                line = dict( color= color, width = 7),name="vector "+ str(args.index(V)+1))
            
                paleta = [[0, color],[1, color]]

                cono = go.Cone(x=[V[1][0]-0.063*(V[1][0]-V[0][0])], y=[V[1][1]-0.063*(V[1][1]-V[0][1])], z=[V[1][2]-0.063*(V[1][2]-V[0][2])], u=[0.5*(V[1][0]-V[0][0])], v=[0.5*(V[1][1]-V[0][1])], w=[0.5*(V[1][2]-V[0][2])],sizemode="absolute",sizeref=escala,anchor="cm",
                showscale=False,
                colorscale=paleta,
                hoverinfo = "skip",
                colorbar=dict(thickness=20, ticklen=4),
                name="vector "+ str(args.index(V)+1))
            
                data += [vector,cono]
                layout = go.Layout(margin = dict( l = 0,r = 0,b = 0,t = 0))

            if  type(V[1]) == list:

                x.append(V[0][0])
                x.append(V[0][0]+V[1][0])

                y.append(V[0][1])
                y.append(V[0][1]+V[1][1])

                z.append(V[0][2])
                z.append(V[0][2]+V[1][2])

                nombre = "Tail"+ "=" + "(" + str(V[0][0])  + "," + str(V[0][1]) +"," +str(V[0][2]) + ")" + "\n" + "Head"+ "=" + "(" + str(V[0][0]+V[1][0])  + "," + str(V[0][1]+V[1][1]) +"," +str(V[0][2]+V[1][2]) + ")"

                color = randomRgbaColor()
                vector = go.Scatter3d( 
                x = [V[0][0],V[0][0]+V[1][0]],
                y = [V[0][1],V[0][1]+V[1][1]],
                z = [V[0][2],V[0][2]+V[1][2]],
                hoverinfo = "name + text",
                hovertext = nombre,
                marker = dict( size = 1,color= color),
                line = dict( color= color, width = 7),name="vector "+ str(args.index(V)+1))
            
                paleta = [[0, color],[1, color]]

                cono = go.Cone(x=[(V[0][0]+V[1][0])-0.063*((V[0][0]+V[1][0])-V[0][0])], y=[(V[0][1]+V[1][1])-0.063*((V[0][1]+V[1][1])-V[0][1])], z=[(V[0][2]+V[1][2])-0.063*((V[0][2]+V[1][2])-V[0][2])], u=[0.5*((V[0][0]+V[1][0])-V[0][0])], v=[0.5*((V[0][1]+V[1][1])-V[0][1])], w=[0.5*((V[0][2]+V[1][2])-V[0][2])],sizemode="absolute",sizeref=escala,anchor="cm",
                showscale=False,
                colorscale=paleta,
                hoverinfo = "skip",
                colorbar=dict(thickness=20, ticklen=4),
                name="vector "+ str(args.index(V)+1))
            
                data += [vector,cono]
                layout = go.Layout(margin = dict( l = 0,r = 0,b = 0,t = 0))

            if type(V[1]) != list and type(V[1]) != tuple:

                a = np.array(V[1]).astype(np.float64).tolist()[0][0]
                b = np.array(V[1]).astype(np.float64).tolist()[1][0]
                c = np.array(V[1]).astype(np.float64).tolist()[2][0]

                x.append(V[0][0])
                x.append(V[0][0]+a)

                y.append(V[0][1])
                y.append(V[0][1]+b)

                z.append(V[0][2])
                z.append(V[0][2]+c)

                nombre = "Tail"+ "=" + "(" + str(V[0][0])  + "," + str(V[0][1]) +"," +str(V[0][2]) + ")" + "\n" + "Head"+ "=" + "(" + str(V[0][0]+a)  + "," + str(V[0][1]+b) +"," +str(V[0][2]+c) + ")"

                color = randomRgbaColor()
                vector = go.Scatter3d( 
                x = [V[0][0],V[0][0]+a],
                y = [V[0][1],V[0][1]+b],
                z = [V[0][2],V[0][2]+c],
                hoverinfo = "name + text",
                hovertext = nombre,
                marker = dict( size = 1,color= color),
                line = dict( color= color, width = 7),name="vector "+ str(args.index(V)+1))
            
                paleta = [[0, color],[1, color]]

                cono = go.Cone(x=[(V[0][0]+a)-0.063*((V[0][0]+a)-V[0][0])], y=[(V[0][1]+b)-0.063*((V[0][1]+b)-V[0][1])], z=[(V[0][2]+c)-0.063*((V[0][2]+c)-V[0][2])], u=[0.5*((V[0][0]+a)-V[0][0])], v=[0.5*((V[0][1]+b)-V[0][1])], w=[0.5*((V[0][2]+c)-V[0][2])],sizemode="absolute",sizeref=escala,anchor="cm",
                showscale=False,
                colorscale=paleta,
                hoverinfo = "skip",
                colorbar=dict(thickness=20, ticklen=4),
                name="vector "+ str(args.index(V)+1))
            
                data += [vector,cono]
                layout = go.Layout(margin = dict( l = 0,r = 0,b = 0,t = 0))


        if type(V) != list:

            a = np.array(V).astype(np.float64).tolist()[0][0]
            b = np.array(V).astype(np.float64).tolist()[1][0]
            c = np.array(V).astype(np.float64).tolist()[2][0]

            x.append(a)
            y.append(b)
            z.append(c)

            color = randomRgbaColor()
            vector = go.Scatter3d( 
            x = [0,a],
            y = [0,b],
            z = [0,c],
            marker = dict( size = 1,color= color),
            line = dict( color= color, width = 7),name="vector "+ str(args.index(V)+1))
        
            paleta = [[0, color],[1, color]]

            cono = go.Cone(x=[a], y=[b], z=[c], u=[a], v=[b], w=[c],sizemode="absolute",sizeref=escala,anchor="cm",
               showscale=False,
               colorscale=paleta,
               colorbar=dict(thickness=20, ticklen=4),
               name="vector "+ str(args.index(V)+1))
        
            data += [vector,cono]
            layout = go.Layout(margin = dict( l = 0,r = 0,b = 0,t = 0))




    paleta2 = [[0, "#2a3f5f"],[1, "#2a3f5f"]]
    point = go.Scatter3d( x = [0],y = [0],z = [0], mode='markers',marker=dict(color= "#2a3f5f",size=5),showlegend=True,name="origen")
    
    axex = go.Scatter3d( 
        x = [min(x)-escala, max(x)+escala],
        y = [0,0],
        z = [0,0],
        hoverinfo = "skip",
        marker = dict( size = 1,color= "#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="")
    
    
    conox = go.Cone(x=[max(x)+escala], y=[0], z=[0], u=[max(x)+escala], v=[0], w=[0],sizemode="absolute",sizeref= escala*0.6,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo = "name",
               colorbar=dict(thickness=20, ticklen=4),name="Eje x-positivo")
    
    axey = go.Scatter3d( 
        x = [0,0],
        y = [min(y)-escala,max(y)+escala],
        z = [0,0],
        hoverinfo = "skip",
        marker = dict( size = 1,color="#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="")
    
    conoy = go.Cone(x=[0], y=[max(y)+escala], z=[0], u=[0], v=[max(y)+escala], w=[0],sizemode="absolute",sizeref=escala*0.6,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo = "name",
               colorbar=dict(thickness=20, ticklen=4),
               name="Eje y-positivo ")
    
    axez = go.Scatter3d( 
        x = [0,0],
        y = [0,0],
        z = [min(z)-escala,max(z)+escala],
        hoverinfo = "skip",
        marker = dict( size = 1,color= "#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="eje z-positivo")
    
    conoz = go.Cone(x=[0], y=[0], z=[max(z)+escala], u=[0], v=[0], w=[max(z)+escala],sizemode="absolute",sizeref=escala*0.6,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo= "name",
               colorbar=dict(thickness=20, ticklen=4),
               name="Eje z-positivo")
    
    
    #plano = go.Surface(x = np.linspace(min(x),max(x),500), y = np.linspace(min(y),max(y),500) ,z = np.zeros(500),showscale=False)

    fig = go.Figure(data= data + [point, axex, conox, axey, conoy, axez, conoz] ,layout=layout)


    fig.update_layout(legend=dict(orientation="h",y=1.3,x=0.03),title_font=dict(size=50, color='rgb(1,21,51)'),showlegend=True,width=480, height=480)


    plot(fig,image_height=800,image_width=800)
    fig.show()

from sympy import Matrix

A = Matrix([6,3,5])


plotvectors3D([1,2,3],[(1,2,3),(5,4,6)],[(5,4,6),[1,2,3]],A,[(6,3,5),A])

plotvectors3D([1,2,3],[(1,2,3),(5,4,6)],[5,4,6],[4,2,3])

"""## **DEFINICIÓN DE UNA FUNCIÓN PARA GRAFICAR MULTIPLES VECTORES FIJOS EN FORMA POLAR EN EL PLANO**
La función tiene como sintaxis **plotpolarvectorsf2D** permite graficar multiples vectores fijos en el plano en forma polar.
"""

import plotly.graph_objects as go
import numpy as np
import math


def plotpolarvectorsf2D(*args):

    '''Función elaborada con el módulo Plotly y NumPy  para representar multiples vectores fijos en el plano en forma polar'''
    
    fig = go.Figure()
    x = [0]
    y = [0]

    for v in args:

        r = v[0]
        theta_str = v[1]
        theta = math.radians(float(theta_str[:-1]))

        coor1 = round(r*math.cos(theta),3)
        coor2 = round(r*math.sin(theta),3)

        color = randomRgbaColor()
        x.append(coor1)
        y.append(coor2)
        #fig.add_trace(go.Scatter(x=[V[0]],y=[V[1]],mode='markers',marker=dict(color= color,size=7),showlegend=True,name="vector "+ str(args.index(V)+1)))
        fig.add_trace(go.Scatter(x=[0,coor1], y=[0,coor2],mode='lines',marker=dict(color= color,size=8),showlegend=True,name="vector "+ str(args.index(v)+1)))
        fig.add_annotation(
        x=coor1,  # Coordenada en x cabeza
        y=coor2,  # Coordenada en y cabeza
        ax=0.0,  # Coordenada en x de la cola
        ay=0.0,  # Coordenada en x de la cola
        xref='x',
        yref='y',
        axref='x',
        ayref='y',
        showarrow=True,
        arrowhead=2,
        arrowsize=1.5,
        arrowwidth=2.3,
        arrowcolor = color)
        
    fig.add_trace(go.Scatter(x=[0],y=[0],mode='markers',marker=dict(color="#2a3f5f",size=9),showlegend=True,opacity=1,name="origen"))

    fig.add_annotation(ax = min(x)-0.54, axref = 'x', ay = 0, ayref = 'y',x = max(x)+0.5, xref = 'x', y = 0, yref = 'y',arrowwidth = 1.5, arrowhead = 2,arrowcolor = "#2a3f5f")
    fig.add_annotation(ax = 0, axref = 'x', ay = min(y) - 1, ayref = 'y',x = 0, xref = 'x', y = max(y)+0.5, yref = 'y',arrowwidth = 1.5, arrowhead = 2,arrowcolor = "#2a3f5f")
    fig.add_annotation(text="$x$", x=max(x)+0.5, y=-0.2, arrowhead=1, showarrow=False)
    fig.add_annotation(text="$y$", x=-0.3, y=max(y)+0.5, arrowhead=1, showarrow=False)

    fig.update_xaxes(title = "$\large{x}$", title_font=dict(size=30, family='latex', color='rgb(1,21,51)'),range = [min(x)-0.5, max(x)+0.5],showgrid = True) #,zerolinecolor="black" ,autorange = True
    fig.update_yaxes(title = "$\large{y}$", title_font=dict(size=30, family='latex', color='rgb(1,21,51)'),range = [min(y)-0.5, max(y)+0.5],showgrid = True) #, zerolinecolor= "black" ,autorange = True
    fig.update_layout(font=dict(family="latex",size=20,color="black")) #y=1.2,x=0.03
    #fig.update_layout(title= "",title_font=dict(size=5, family='latex', color='rgb(1,21,51)'),title_x=0.5)
    fig.update_layout(legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, itemdoubleclick ="toggle"),title_font=dict(size=30, color='rgb(1,21,51)'),showlegend=True,width=500, height=480)
    fig.show()

plotpolarvectorsf2D([20,"30°"],[30,"60°"],[20,"90°"],[15,"120°"],[40,"280°"])

"""## **DEFINICIÓN DE LA FUNCIÓN PARA GRAFICAR MULTIPLES VECTORES LIBRES EN FORMA POLAR EN EL PLANO**
La función tiene como sintaxis **plotpolarvectorsl2D** permite graficar multiples vectores libres en el plano en forma polar.
"""

import plotly.graph_objects as go
import numpy as np
import math


def plotpolarvectorsl2D(*args):

    '''Función elaborada con el módulo Plotly y NumPy  para representar multiples vectores libres en el plano en forma polar'''
    
    fig = go.Figure()
    x = [0]
    y = [0]

    for v in args:

        p_x = v[0][0]
        p_y = v[0][1]

        r = v[1][0]
        theta_str = v[1][1]
        theta = math.radians(float(theta_str[:-1]))

        coor1 = round(r*math.cos(theta),3)
        coor2 = round(r*math.sin(theta),3)

        color = randomRgbaColor()
        x.append(coor1 + p_x)
        x.append(p_x)
        y.append(coor2 + p_y)
        y.append(p_y)
        #fig.add_trace(go.Scatter(x=[V[0]],y=[V[1]],mode='markers',marker=dict(color= color,size=7),showlegend=True,name="vector "+ str(args.index(V)+1)))
        fig.add_trace(go.Scatter(x=[p_x,coor1+p_x], y=[p_y,coor2+p_y],mode='lines',marker=dict(color= color,size=8),showlegend=True,name="vector "+ str(args.index(v)+1)))
        fig.add_annotation(
        x=coor1 + p_x,  # Coordenada en x cabeza
        y=coor2 + p_y,  # Coordenada en y cabeza
        ax=p_x,  # Coordenada en x de la cola
        ay=p_y,  # Coordenada en x de la cola
        xref='x',
        yref='y',
        axref='x',
        ayref='y',
        showarrow=True,
        arrowhead=2,
        arrowsize=1.5,
        arrowwidth=2.3,
        arrowcolor = color)
        
    fig.add_trace(go.Scatter(x=[0],y=[0],mode='markers',marker=dict(color="#2a3f5f",size=9),showlegend=True,opacity=1,name="origen"))

    fig.add_annotation(ax = min(x)-0.54, axref = 'x', ay = 0, ayref = 'y',x = max(x)+0.5, xref = 'x', y = 0, yref = 'y',arrowwidth = 1.5, arrowhead = 2,arrowcolor = "#2a3f5f")
    fig.add_annotation(ax = 0, axref = 'x', ay = min(y)-0.54, ayref = 'y',x = 0, xref = 'x', y = max(y)+0.5, yref = 'y',arrowwidth = 1.5, arrowhead = 2,arrowcolor = "#2a3f5f")
    fig.add_annotation(text="$x$", x=max(x)+0.5, y=-0.2, arrowhead=1, showarrow=False)
    fig.add_annotation(text="$y$", x=-0.3, y=max(y)+0.5, arrowhead=1, showarrow=False)

    fig.update_xaxes(title = "$\large{x}$", title_font=dict(size=30, family='latex', color='rgb(1,21,51)'),range = [min(x)-0.5, max(x)+0.5],showgrid = True) #,zerolinecolor="black" ,autorange = True
    fig.update_yaxes(title = "$\large{y}$", title_font=dict(size=30, family='latex', color='rgb(1,21,51)'),range = [min(y)-0.5, max(y)+0.5],showgrid = True) #, zerolinecolor= "black" ,autorange = True
    fig.update_layout(font=dict(family="latex",size=20,color="black")) #y=1.2,x=0.03
    #fig.update_layout(title= "",title_font=dict(size=5, family='latex', color='rgb(1,21,51)'),title_x=0.5)
    fig.update_layout(legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, itemdoubleclick ="toggle"),title_font=dict(size=30, color='rgb(1,21,51)'),showlegend=True,width=500, height=480)
    fig.show()

plotpolarvectorsl2D([(1,2),(5,"-60°")],[(3.5,-2.33),(5,"90°")],[(3.5,2.67),(2,"140°")])

"""## **DEFINICIÓN DE LA FUNCIÓN PARA GRAFICAR MULTIPLES VECTORES LIBRES Y FIJOS EN FORMA POLAR EN EL PLANO**
La función tiene como sintaxis **plotpolarvectors2D** permite graficar multiples vectores libres en el plano en forma polar.
"""

import plotly.graph_objects as go
import numpy as np
import math


def plotpolarvectors(*args):

    '''Función elaborada con el módulo Plotly y NumPy  para representar multiples vectores fijos y libres  en el plano en forma polar'''
    
    fig = go.Figure()
    x = [0]
    y = [0]
    for v in args:

        if type(v[0]) == int or type(v[0]) == float :
            r = v[0]
            theta_str = v[1]
            theta = math.radians(float(theta_str[:-1]))

            coor1 = round(r*math.cos(theta),3)
            coor2 = round(r*math.sin(theta),3)

            color = randomRgbaColor()
            x.append(coor1)
            y.append(coor2)
            #fig.add_trace(go.Scatter(x=[V[0]],y=[V[1]],mode='markers',marker=dict(color= color,size=7),showlegend=True,name="vector "+ str(args.index(V)+1)))
            fig.add_trace(go.Scatter(x=[0,coor1], y=[0,coor2],mode='lines',marker=dict(color= color,size=8),showlegend=True,name="vector "+ str(args.index(v)+1)))
            fig.add_annotation(
            x=coor1,  # Coordenada en x cabeza
            y=coor2,  # Coordenada en y cabeza
            ax=0.0,  # Coordenada en x de la cola
            ay=0.0,  # Coordenada en x de la cola
            xref='x',
            yref='y',
            axref='x',
            ayref='y',
            showarrow=True,
            arrowhead=2,
            arrowsize=1.5,
            arrowwidth=2.3,
            arrowcolor = color)

        else:

            p_x = v[0][0]
            p_y = v[0][1]

            r = v[1][0]
            theta_str = v[1][1]
            theta = math.radians(float(theta_str[:-1]))

            coor1 = round(r*math.cos(theta),3)
            coor2 = round(r*math.sin(theta),3)

            color = randomRgbaColor()
            x.append(coor1 + p_x)
            x.append(p_x)
            y.append(coor2 + p_y)
            y.append(p_y)
            #fig.add_trace(go.Scatter(x=[V[0]],y=[V[1]],mode='markers',marker=dict(color= color,size=7),showlegend=True,name="vector "+ str(args.index(V)+1)))
            fig.add_trace(go.Scatter(x=[p_x,coor1+p_x], y=[p_y,coor2+p_y],mode='lines',marker=dict(color= color,size=8),showlegend=True,name="vector "+ str(args.index(v)+1)))
            fig.add_annotation(
            x=coor1 + p_x,  # Coordenada en x cabeza
            y=coor2 + p_y,  # Coordenada en y cabeza
            ax=p_x,  # Coordenada en x de la cola
            ay=p_y,  # Coordenada en x de la cola
            xref='x',
            yref='y',
            axref='x',
            ayref='y',
            showarrow=True,
            arrowhead=2,
            arrowsize=1.5,
            arrowwidth=2.3,
            arrowcolor = color)
            
    fig.add_trace(go.Scatter(x=[0],y=[0],mode='markers',marker=dict(color="#2a3f5f",size=9),showlegend=True,opacity=1,name="origen"))

    fig.add_annotation(ax = min(x)-0.54, axref = 'x', ay = 0, ayref = 'y',x = max(x)+0.5, xref = 'x', y = 0, yref = 'y',arrowwidth = 1.5, arrowhead = 2,arrowcolor = "#2a3f5f")
    fig.add_annotation(ax = 0, axref = 'x', ay = min(y)-0.54, ayref = 'y',x = 0, xref = 'x', y = max(y)+0.5, yref = 'y',arrowwidth = 1.5, arrowhead = 2,arrowcolor = "#2a3f5f")
    fig.add_annotation(text="$x$", x=max(x)+0.5, y=-0.2, arrowhead=1, showarrow=False)
    fig.add_annotation(text="$y$", x=-0.3, y=max(y)+0.5, arrowhead=1, showarrow=False)

    fig.update_xaxes(title = "$\large{x}$", title_font=dict(size=30, family='latex', color='rgb(1,21,51)'),range = [min(x)-0.5, max(x)+0.5],showgrid = True) #,zerolinecolor="black" ,autorange = True
    fig.update_yaxes(title = "$\large{y}$", title_font=dict(size=30, family='latex', color='rgb(1,21,51)'),range = [min(y)-0.5, max(y)+0.5],showgrid = True) #, zerolinecolor= "black" ,autorange = True
    fig.update_layout(font=dict(family="latex",size=20,color="black")) #y=1.2,x=0.03
    #fig.update_layout(title= "",title_font=dict(size=5, family='latex', color='rgb(1,21,51)'),title_x=0.5)
    fig.update_layout(legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, itemdoubleclick ="toggle"),title_font=dict(size=30, color='rgb(1,21,51)'),showlegend=True,width=500, height=480)
    fig.show()

plotpolarvectors([4,"30°"],[(3.464,2),(5,"120°")],[(0.964,6.33),(4,"265°")])

"""## **DEFINICIÓN DE UNA FUNCIÓN PARA GRAFICAR MULTIPLES VECTORES FIJOS EN EL ESPACIO EN TÉRMINOS DE SU MAGNITUD Y UN VECTOR DIRECCIÓN UNITARIO**
La función tiene como sintaxis **plotdirectvectorsf3D** permite realizar la representación gráfica de multiples vectores fijos en el espacio segun su magnitud y vector dirección unitario.
"""

import plotly.graph_objs as go
from plotly.offline import plot
import numpy as np
#i = (1,0,0)
#j = (0,1,0)
#k = (0,0,1)

#mi = (-1,0,0)
#mj = (0,-1,0)
#mk = (0,0,-1)

def plotdirectvectorsf3D(*args):

    ''''Función elaborada con el módulo Plotly y NumPy para representar gráficamente multiples vectores fijos en el espacio dada su magnitud y
       vector dirección unitario'''

    data = []
    x = [0]
    y = [0]
    z = [0.3,-0.3]

    for v in args:

        magni = v[0]

        dir_x = v[1][0]
        dir_y = v[1][1]
        dir_z = v[1][2]

        V = [magni *v[1][0],magni*v[1][1],magni*v[1][2]]

        x.append(V[0])
        y.append(V[1])
        z.append(V[2])

    escala =(max(x)+max(y)+max(z))/20

    
    for v in args:

        magni = v[0]

        dir_x = v[1][0]
        dir_y = v[1][1]
        dir_z = v[1][2]

        V = [magni *v[1][0],magni*v[1][1],magni*v[1][2]]

        #x.append(V[0])
        #y.append(V[1])
        #z.append(V[2])
        color = randomRgbaColor()
        vector = go.Scatter3d( 
        x = [0,V[0]],
        y = [0,V[1]],
        z = [0,V[2]],
        marker = dict( size = 1,color= color),
        line = dict( color= color, width = 7),name="vector "+ str(args.index(v)+1))
        
        paleta = [[0, color],[1, color]]

        cono = go.Cone(x=[V[0]], y=[V[1]], z=[V[2]], u=[V[0]], v=[V[1]], w=[V[2]],sizemode="absolute",sizeref= escala,anchor="cm",
               showscale=False,
               colorscale=paleta,
               colorbar=dict(thickness=20, ticklen=4),
               name="vector "+ str(args.index(v)+1))
        
        data += [vector,cono]
        layout = go.Layout(margin = dict( l = 0,r = 0,b = 0,t = 0))

    paleta2 = [[0, "#2a3f5f"],[1, "#2a3f5f"]]
    point = go.Scatter3d( x = [0],y = [0],z = [0], mode='markers',marker=dict(color= "#2a3f5f",size=5),showlegend=True,name="origen")
    
    axex = go.Scatter3d( 
        x = [min(x)- escala, max(x)+escala],
        y = [0,0],
        z = [0,0],
        hoverinfo = "skip",
        marker = dict( size = 1,color= "#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="")
    
    
    conox = go.Cone(x=[max(x)+escala], y=[0], z=[0], u=[max(x)+escala], v=[0], w=[0],sizemode="absolute",sizeref=escala*0.5,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo = "name",
               colorbar=dict(thickness=20, ticklen=4),name="Eje x-positivo")
    
    axey = go.Scatter3d( 
        x = [0,0],
        y = [min(y)-escala,max(y)+escala],
        z = [0,0],
        hoverinfo = "skip",
        marker = dict( size = 1,color="#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="")
    
    conoy = go.Cone(x=[0], y=[max(y)+escala], z=[0], u=[0], v=[max(y)+escala], w=[0],sizemode="absolute",sizeref=escala*0.5,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo = "name",
               colorbar=dict(thickness=20, ticklen=4),
               name="Eje y-positivo ")
    
    axez = go.Scatter3d( 
        x = [0,0],
        y = [0,0],
        z = [min(z)-escala,max(z)+escala],
        hoverinfo = "skip",
        marker = dict( size = 1,color= "#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="eje z-positivo")
    
    conoz = go.Cone(x=[0], y=[0], z=[max(z)+escala], u=[0], v=[0], w=[max(z)+escala],sizemode="absolute",sizeref=escala*0.5,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo= "name",
               colorbar=dict(thickness=20, ticklen=4),
               name="Eje z-positivo")
    
    
    #plano = go.Surface(x = np.linspace(min(x),max(x),500), y = np.linspace(min(y),max(y),500) ,z = np.zeros(500),showscale=False)

    fig = go.Figure(data= data + [point, axex, conox, axey, conoy, axez, conoz] ,layout=layout)


    fig.update_layout(legend=dict(orientation="h",y=1.3,x=0.03),title_font=dict(size=50, color='rgb(1,21,51)'),showlegend=True,width=480, height=480)


    plot(fig,image_height=800,image_width=800)
    fig.show()

plotdirectvectorsf3D([3,(np.cos(30),np.cos(20),np.cos(60))])

"""## **DEFINICIÓN DE UNA FUNCIÓN PARA GRAFICAR MULTIPLES VECTORES LIBRES EN EL ESPACIO EN TÉRMINOS DE SU MAGNITUD Y UN VECTOR DIRECCIÓN UNITARIO**
La función tiene como sintaxis **plotdirectvectorsl3D** permite realizar la representación gráfica de multiples vectores fijos en el espacio segun su magnitud y vector dirección unitario.
"""

import plotly.graph_objs as go
from plotly.offline import plot
import numpy as np


#i = (1,0,0)
#j = (0,1,0)
#k = (0,0,1)

#mi = (-1,0,0)
#mj = (0,-1,0)
#mk = (0,0,-1)



def plotdirectvectorsl3D(*args):
    '''Función elaborada en el módulo Plotly y NumPy para representar graficamente multiples vectores libres en el espacio en terminos 
    de la magnitud y un vector dirección unitario'''

    data = []
    x = [0]
    y = [0]
    z = [0.3,-0.3]

    for v in args:
        
        p_x = v[0][0]
        p_y = v[0][1]
        p_z = v[0][2]


        magni = v[1]

        dir_x = v[2][0]
        dir_y = v[2][1]
        dir_z = v[2][2]

        V = [magni *dir_x+p_x ,magni*dir_y+p_y,magni*dir_z+p_z]

        x.append(p_x)
        y.append(p_y)
        z.append(p_z)


        x.append(V[0])
        y.append(V[1])
        z.append(V[2])

    escala =(max(x)+max(y)+max(z))/20



    for v in args:

        p_x = v[0][0]
        p_y = v[0][1]
        p_z = v[0][2]


        magni = v[1]

        dir_x = v[2][0]
        dir_y = v[2][1]
        dir_z = v[2][2]

        V = [magni *dir_x+p_x ,magni*dir_y+p_y,magni*dir_z+p_z]

        x.append(p_x)
        y.append(p_y)
        z.append(p_z)


        x.append(V[0])
        y.append(V[1])
        z.append(V[2])

        nombre = "Tail"+ "=" + "(" + str(v[0][0])  + "," + str(v[0][1]) +"," +str(v[0][2]) + ")" + "\n" + "Head"+ "=" + "(" + str(V[0])  + "," + str(V[1]) +"," +str(V[2]) + ")"

        color = randomRgbaColor()
        vector = go.Scatter3d( 
        x = [p_x,V[0]],
        y = [p_y,V[1]],
        z = [p_z,V[2]],
        hoverinfo = "name + text",
        hovertext = nombre,
        marker = dict( size = 1,color= color),
        line = dict( color= color, width = 7),name="vector "+ str(args.index(v)+1))
        
        paleta = [[0, color],[1, color]]

        cono = go.Cone(x=[V[0]-0.063*(V[0]-p_x)], y=[V[1]-0.063*(V[1]-p_y)], z=[V[2]-0.063*(V[2]-p_z)], u=[0.5*(V[0]-p_x)], v=[0.5*(V[1]-p_y)], w=[0.5*(V[2]-p_z)],sizemode="absolute",sizeref=escala,anchor="cm",
               showscale=False,
               colorscale=paleta,
               hoverinfo = "skip",
               colorbar=dict(thickness=20, ticklen=4),
               name="vector "+ str(args.index(v)+1))
        
        data += [vector,cono]
        layout = go.Layout(margin = dict( l = 0,r = 0,b = 0,t = 0))

    paleta2 = [[0, "#2a3f5f"],[1, "#2a3f5f"]]
    point = go.Scatter3d( x = [0],y = [0],z = [0], mode='markers',marker=dict(color= "#2a3f5f",size=5),showlegend=True,name="origen")
    
    axex = go.Scatter3d( 
        x = [min(x)-escala, max(x)+escala],
        y = [0,0],
        z = [0,0],
        hoverinfo = "skip",
        marker = dict( size = 1,color= "#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="")
    
    
    conox = go.Cone(x=[max(x)+escala], y=[0], z=[0], u=[max(x)+escala], v=[0], w=[0],sizemode="absolute",sizeref=escala*0.5,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo = "name",
               colorbar=dict(thickness=20, ticklen=4),name="Eje x-positivo")
    
    axey = go.Scatter3d( 
        x = [0,0],
        y = [min(y)-escala,max(y)+escala],
        z = [0,0],
        hoverinfo = "skip",
        marker = dict( size = 1,color="#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="")
    
    conoy = go.Cone(x=[0], y=[max(y)+escala], z=[0], u=[0], v=[max(y)+escala], w=[0],sizemode="absolute",sizeref=escala*0.5,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo = "name",
               colorbar=dict(thickness=20, ticklen=4),
               name="Eje y-positivo ")
    
    axez = go.Scatter3d( 
        x = [0,0],
        y = [0,0],
        z = [min(z)-escala,max(z)+escala],
        hoverinfo = "skip",
        marker = dict( size = 1,color= "#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="eje z-positivo")
    
    conoz = go.Cone(x=[0], y=[0], z=[max(z)+escala], u=[0], v=[0], w=[max(z)+escala],sizemode="absolute",sizeref=escala*0.5,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo= "name",
               colorbar=dict(thickness=20, ticklen=4),
               name="Eje z-positivo")
    
    
    #plano = go.Surface(x = np.linspace(min(x),max(x),500), y = np.linspace(min(y),max(y),500) ,z = np.zeros(500),showscale=False)

    fig = go.Figure(data= data + [point, axex, conox, axey, conoy, axez, conoz] ,layout=layout)


    fig.update_layout(legend=dict(orientation="h",y=1.3,x=0.03),title_font=dict(size=50, color='rgb(1,21,51)'),showlegend=True,width=480, height=480)


    plot(fig,image_height=800,image_width=800)
    fig.show()

plotdirectvectorsl3D([(1,2,3),2,(1,0,0)],[(1,2,3),5,(0,1,0)],[(1,2,3),2,(0,0,1)],[(1,2,3),3,(1,1,1)],[(1,2,3),4,(-1,0,0)])

"""## **DEFINICIÓN DE UNA FUNCIÓN PARA GRAFICAR MULTIPLES VECTORES FIJOS O LIBRES EN EL ESPACIO EN TÉRMINOS DE SU MAGNITUD Y UN VECTOR DIRECCIÓN UNITARIO**
La función tiene como sintaxis **plotdirectvectors3D** permite realizar la representación gráfica de multiples vectores fijos en el espacio segun su magnitud y vector dirección unitario.
"""

import plotly.graph_objs as go
from plotly.offline import plot
import numpy as np


#i = (1,0,0)
#j = (0,1,0)
#k = (0,0,1)

#mi = (-1,0,0)
#mj = (0,-1,0)
#mk = (0,0,-1)



def plotdirectvectors3D(*args):
    '''Función elaborada en el módulo Plotly y NumPy para representar graficamente multiples vectores libres en el espacio en terminos 
    de la magnitud y un vector dirección unitario'''

    data = []
    x = [0]
    y = [0]
    z = [0.3,-0.3]

    for v in args:

        if type(v[0]) == int or type(v[0]) == float :

             magni = v[0]
             dir_x = v[1][0]
             dir_y = v[1][1]
             dir_z = v[1][2]
             V = [magni *v[1][0],magni*v[1][1],magni*v[1][2]]
             
             x.append(V[0])
             y.append(V[1])
             z.append(V[2])
        else:
            p_x = v[0][0]
            p_y = v[0][1]
            p_z = v[0][2]


            magni = v[1]

            dir_x = v[2][0]
            dir_y = v[2][1]
            dir_z = v[2][2]

            V = [magni *dir_x+p_x ,magni*dir_y+p_y,magni*dir_z+p_z]

            x.append(p_x)
            y.append(p_y)
            z.append(p_z)


            x.append(V[0])
            y.append(V[1])
            z.append(V[2])

    escala =(max(x)+max(y)+max(z))/20

    for v in args:
        if type(v[0]) == int or type(v[0]) == float :

            magni = v[0]

            dir_x = v[1][0]
            dir_y = v[1][1]
            dir_z = v[1][2]

            V = [magni *v[1][0],magni*v[1][1],magni*v[1][2]]

            #x.append(V[0])
            #y.append(V[1])
            #z.append(V[2])
            color = randomRgbaColor()
            vector = go.Scatter3d( 
            x = [0,V[0]],
            y = [0,V[1]],
            z = [0,V[2]],
            marker = dict( size = 1,color= color),
            line = dict( color= color, width = 7),name="vector "+ str(args.index(v)+1))
        
            paleta = [[0, color],[1, color]]

            cono = go.Cone(x=[V[0]], y=[V[1]], z=[V[2]], u=[V[0]], v=[V[1]], w=[V[2]],sizemode="absolute",sizeref= escala,anchor="cm",
               showscale=False,
               colorscale=paleta,
               colorbar=dict(thickness=20, ticklen=4),
               name="vector "+ str(args.index(v)+1))
        
            data += [vector,cono]
            layout = go.Layout(margin = dict( l = 0,r = 0,b = 0,t = 0))

        else:

            p_x = v[0][0]
            p_y = v[0][1]
            p_z = v[0][2]


            magni = v[1]

            dir_x = v[2][0]
            dir_y = v[2][1]
            dir_z = v[2][2]

            V = [magni *dir_x+p_x ,magni*dir_y+p_y,magni*dir_z+p_z]

            x.append(p_x)
            y.append(p_y)
            z.append(p_z)


            x.append(V[0])
            y.append(V[1])
            z.append(V[2])

            nombre = "Tail"+ "=" + "(" + str(v[0][0])  + "," + str(v[0][1]) +"," +str(v[0][2]) + ")" + "\n" + "Head"+ "=" + "(" + str(V[0])  + "," + str(V[1]) +"," +str(V[2]) + ")"

            color = randomRgbaColor()
            vector = go.Scatter3d( 
            x = [p_x,V[0]],
            y = [p_y,V[1]],
            z = [p_z,V[2]],
            hoverinfo = "name + text",
            hovertext = nombre,
            marker = dict( size = 1,color= color),
            line = dict( color= color, width = 7),name="vector "+ str(args.index(v)+1))
        
            paleta = [[0, color],[1, color]]

            cono = go.Cone(x=[V[0]-0.063*(V[0]-p_x)], y=[V[1]-0.063*(V[1]-p_y)], z=[V[2]-0.063*(V[2]-p_z)], u=[0.5*(V[0]-p_x)], v=[0.5*(V[1]-p_y)], w=[0.5*(V[2]-p_z)],sizemode="absolute",sizeref=escala,anchor="cm",
               showscale=False,
               colorscale=paleta,
               hoverinfo = "skip",
               colorbar=dict(thickness=20, ticklen=4),
               name="vector "+ str(args.index(v)+1))
        
            data += [vector,cono]
            layout = go.Layout(margin = dict( l = 0,r = 0,b = 0,t = 0))

    paleta2 = [[0, "#2a3f5f"],[1, "#2a3f5f"]]
    point = go.Scatter3d( x = [0],y = [0],z = [0], mode='markers',marker=dict(color= "#2a3f5f",size=5),showlegend=True,name="origen")
    
    axex = go.Scatter3d( 
        x = [min(x)-escala, max(x)+escala],
        y = [0,0],
        z = [0,0],
        hoverinfo = "skip",
        marker = dict( size = 1,color= "#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="")
    
    
    conox = go.Cone(x=[max(x)+escala], y=[0], z=[0], u=[max(x)+escala], v=[0], w=[0],sizemode="absolute",sizeref=escala*0.5,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo = "name",
               colorbar=dict(thickness=20, ticklen=4),name="Eje x-positivo")
    
    axey = go.Scatter3d( 
        x = [0,0],
        y = [min(y)-escala,max(y)+escala],
        z = [0,0],
        hoverinfo = "skip",
        marker = dict( size = 1,color="#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="")
    
    conoy = go.Cone(x=[0], y=[max(y)+escala], z=[0], u=[0], v=[max(y)+escala], w=[0],sizemode="absolute",sizeref=escala*0.5,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo = "name",
               colorbar=dict(thickness=20, ticklen=4),
               name="Eje y-positivo ")
    
    axez = go.Scatter3d( 
        x = [0,0],
        y = [0,0],
        z = [min(z)-escala,max(z)+escala],
        hoverinfo = "skip",
        marker = dict( size = 1,color= "#2a3f5f"),
        line = dict( color= "#2a3f5f", width = 3), showlegend=False,name="eje z-positivo")
    
    conoz = go.Cone(x=[0], y=[0], z=[max(z)+escala], u=[0], v=[0], w=[max(z)+escala],sizemode="absolute",sizeref=escala*0.5,anchor="cm",
               showscale=False,
               colorscale=paleta2,
               hoverinfo= "name",
               colorbar=dict(thickness=20, ticklen=4),
               name="Eje z-positivo")
    
    
    #plano = go.Surface(x = np.linspace(min(x),max(x),500), y = np.linspace(min(y),max(y),500) ,z = np.zeros(500),showscale=False)

    fig = go.Figure(data= data + [point, axex, conox, axey, conoy, axez, conoz] ,layout=layout)


    fig.update_layout(legend=dict(orientation="h",y=1.3,x=0.03),title_font=dict(size=50, color='rgb(1,21,51)'),showlegend=True,width=480, height=480)


    plot(fig,image_height=800,image_width=800)
    fig.show()

plotdirectvectors3D([(1,2,3),2,(1,0,0)],[2,(1/5,2/5,3/5)],[3,(1,1,1)])